// Continuação do arquivo JavaScript (onde você parou na linha 538)

            // 2. Cria o objeto do usuário no Firestore (CONTINUAÇÃO)
            const newUserObject = {
                email: email,
                isAdmin: false,
                userName: user,
                profilePic: profilePicUrl || 'https://i.imgur.com/G4fB8hL.png', // Imagem de perfil padrão
                teamId: null, // Usuário começa sem time vinculado
                teamName: null,
                createdAt: firebase.firestore.FieldValue.serverTimestamp() // Timestamp de criação
            };

            // Salva o objeto no Firestore usando o UID como ID do documento
            await usersCollection.doc(uid).set(newUserObject);

            alert('✅ Cadastro realizado com sucesso! Você será logado(a) automaticamente.');
            closeRegister();
            // O onAuthStateChanged fará o login e o fetchUserObject será chamado
        
        } catch (error) {
            console.error("Erro no cadastro:", error);
            let message = '❌ Erro desconhecido no Cadastro.';
            if (error.code === 'auth/email-already-in-use') {
                message = '❌ E-mail já cadastrado.';
            } else if (error.code === 'auth/weak-password') {
                message = '❌ Senha muito fraca. Use 6 ou mais caracteres.';
            }
            alert(message);
        }
    }

    // --- Funções do Feed de Notícias ---
    
    function showImagePreview(url) {
        const preview = document.getElementById('image-preview');
        if (url) {
            preview.src = url;
            preview.style.display = 'block';
        } else {
            preview.style.display = 'none';
        }
    }

    async function publishPost() {
        const content = document.getElementById('post-input').value.trim();
        const imageUrl = document.getElementById('post-image-url').value.trim();

        if (!loggedInUserObject || !loggedInUserUID) {
            alert('Você precisa estar logado para publicar.');
            return;
        }

        if (!content) {
            alert('A postagem não pode ser vazia.');
            return;
        }
        
        // Limita o tamanho do post (maxlength: 300 no HTML)
        if (content.length > 300) {
            alert('A postagem não pode ter mais de 300 caracteres.');
            return;
        }

        try {
            await postsCollection.add({
                authorId: loggedInUserUID,
                authorName: loggedInUserObject.userName || loggedInUserObject.email,
                content: content,
                imageUrl: imageUrl || null,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });

            document.getElementById('post-input').value = '';
            document.getElementById('post-image-url').value = '';
            showImagePreview('');
            alert('Postagem publicada com sucesso!');
        } catch (error) {
            console.error("Erro ao publicar post:", error);
            alert("❌ Falha ao publicar post. Verifique as regras de escrita do Firestore.");
        }
    }

    function renderFeed() {
        const feedContainer = document.getElementById('feed-posts');
        feedContainer.innerHTML = '';
        
        if (allPostsCache.length === 0) {
            feedContainer.innerHTML = '<p style="color:#ccc; text-align:center;">Nenhuma notícia ou postagem ainda. Seja o primeiro a publicar!</p>';
            return;
        }

        allPostsCache.forEach(post => {
            // Tenta encontrar o objeto completo do autor no cache
            const author = allUsersCache.find(u => u.uid === post.authorId) || { userName: post.authorName || 'Membro Desconhecido' };
            
            // Formata o timestamp (se existir)
            let dateStr = 'Há pouco tempo';
            if (post.timestamp && post.timestamp.toDate) {
                dateStr = post.timestamp.toDate().toLocaleString('pt-BR', { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit' });
            }

            const postElement = document.createElement('div');
            postElement.className = 'post';
            postElement.innerHTML = `
                <div class="post-header">
                    <img src="${author.profilePic || 'https://i.imgur.com/G4fB8hL.png'}" alt="Foto de Perfil" style="width: 35px; height: 35px; border-radius: 50%; margin-right: 10px; object-fit: cover; border: 2px solid ${author.isAdmin ? '#ff004c' : '#00ff96'};">
                    <span class="post-author">${author.userName || author.email} ${author.isAdmin ? '(ADMIN)' : ''}</span>
                    <span class="post-date"> - ${dateStr}</span>
                </div>
                ${post.imageUrl ? `<img src="${post.imageUrl}" alt="Imagem do Post" style="max-width: 100%; height: auto; border-radius: 8px; margin-top: 10px; margin-bottom: 10px; border: 1px solid #00ff96;">` : ''}
                <div class="post-content">${post.content}</div>
            `;
            feedContainer.appendChild(postElement);
        });
    }

    // --- Funções de Classificação (Lógica de Ordenação) ---

    // Função auxiliar para calcular o Saldo de Gols (SG)
    function calculateStats(stats) {
        stats.Saldo = stats.GolsPro - stats.GolsContra;
        return stats;
    }
    
    // Função de comparação para ordenar a tabela
    function compareTeams(a, b) {
        // 1. PONTOS (P)
        if (a.Pontos !== b.Pontos) return b.Pontos - a.Pontos;
        // 2. NÚMERO DE VITÓRIAS (V)
        if (a.Vitórias !== b.Vitórias) return b.Vitórias - a.Vitórias;
        // 3. SALDO DE GOLS (SG)
        if (a.Saldo !== b.Saldo) return b.Saldo - a.Saldo;
        // 4. GOLS PRÓ (GP)
        if (a.GolsPro !== b.GolsPro) return b.GolsPro - a.GolsPro;
        // 5. NOME (Critério de desempate final)
        if (a.Team < b.Team) return -1;
        if (a.Team > b.Team) return 1;
        return 0;
    }
    
    function renderClassificationTables() {
        // Mapeia o estado atual dos times a partir do cache de usuários
        const teamStats = {};
        
        // Inicializa o objeto teamStats com todos os times e estatísticas zeradas
        Object.keys(teamData).forEach(teamName => {
            teamStats[teamName] = { 
                Team: teamName, 
                Series: teamData[teamName].series,
                ...defaultStats
            };
        });
        
        // Atualiza as estatísticas com base nos documentos dos usuários
        allUsersCache.forEach(user => {
            if (user.teamName && teamStats[user.teamName] && user.stats) {
                // Sobrescreve as estatísticas padrão com as do usuário (que são as estatísticas reais)
                teamStats[user.teamName] = { 
                    Team: user.teamName, 
                    Series: teamData[user.teamName].series,
                    ...user.stats 
                };
            }
        });
        
        // Separa e ordena as Séries A e B
        const serieA = Object.values(teamStats)
            .filter(t => t.Series === 'Série A')
            .map(calculateStats)
            .sort(compareTeams);

        const serieB = Object.values(teamStats)
            .filter(t => t.Series === 'Série B')
            .map(calculateStats)
            .sort(compareTeams);

        // --- Renderiza a Tabela da Série A ---
        const tableA = document.getElementById('tabela-serie-a');
        const tbodyA = tableA.querySelector('tbody');
        tbodyA.innerHTML = '';
        serieA.forEach((team, index) => {
            const row = tbodyA.insertRow();
            row.innerHTML = `
                <td>${index + 1}</td>
                <td><span class="team-link" onclick="openPerfilTime('${team.Team}')">${team.Team}</span></td>
                <td>${team.Pontos}</td>
                <td>${team.Jogos}</td>
                <td>${team.Vitórias}</td>
                <td>${team.Empates}</td>
                <td>${team.Derrotas}</td>
                <td>${team.GolsPro}</td>
                <td>${team.GolsContra}</td>
                <td>${team.Saldo}</td>
            `;
        });
        document.getElementById('series-a-status').style.display = 'none';
        tableA.style.display = 'table';

        // --- Renderiza a Tabela da Série B ---
        const tableB = document.getElementById('tabela-serie-b');
        const tbodyB = tableB.querySelector('tbody');
        tbodyB.innerHTML = '';
        serieB.forEach((team, index) => {
            const row = tbodyB.insertRow();
            row.innerHTML = `
                <td>${index + 1}</td>
                <td><span class="team-link" onclick="openPerfilTime('${team.Team}')">${team.Team}</span></td>
                <td>${team.Pontos}</td>
                <td>${team.Jogos}</td>
                <td>${team.Vitórias}</td>
                <td>${team.Empates}</td>
                <td>${team.Derrotas}</td>
                <td>${team.GolsPro}</td>
                <td>${team.GolsContra}</td>
                <td>${team.Saldo}</td>
            `;
        });
        document.getElementById('series-b-status').style.display = 'none';
        tableB.style.display = 'table';
    }

    // --- Funções da Lista de Times (Geral) ---

    function renderTeamsList() {
        const teamsContainer = document.getElementById('times-list');
        teamsContainer.innerHTML = '';
        
        const linkedTeams = allUsersCache.filter(u => u.teamName);
        const unlinkedTeams = Object.keys(teamData).filter(teamName => 
            !linkedTeams.some(u => u.teamName === teamName)
        );

        let html = '<h3 style="color:#00ff96; margin-top:0;">Times Vinculados a Usuários</h3>';
        if (linkedTeams.length > 0) {
            linkedTeams.forEach(user => {
                const team = teamData[user.teamName];
                html += `
                    <div class="card" onclick="openPerfilTime('${user.teamName}')" style="cursor:pointer; display:flex; align-items:center; gap: 15px;">
                        <img src="${team.logo}" alt="${user.teamName} Logo" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover;">
                        <div>
                            <span style="font-weight: bold; color: #f2c94c; font-size: 1.2rem;">${user.teamName}</span> - <span style="font-size: 0.9em; color: #00ff96;">${team.series}</span>
                            <p style="margin: 5px 0 0 0; color: #ccc;">Gerente: ${user.userName || 'Nome não definido'}</p>
                        </div>
                    </div>
                `;
            });
        } else {
            html += '<p style="color:#ccc;">Nenhum time foi vinculado a um usuário ainda.</p>';
        }

        html += '<h3 style="color:#ff004c; margin-top:30px;">Times Disponíveis para Vínculo</h3>';
        if (unlinkedTeams.length > 0) {
            html += '<ul style="list-style: none; padding: 0;">';
            unlinkedTeams.forEach(teamName => {
                const team = teamData[teamName];
                html += `
                    <li style="padding: 5px 0; border-bottom: 1px dashed rgba(255,255,255,0.1);">
                        <img src="${team.logo}" alt="${teamName} Logo" style="width: 20px; height: 20px; border-radius: 50%; object-fit: cover; margin-right: 10px;">
                        <span style="font-weight: bold;">${teamName}</span> - <span style="color:#999;">${team.series}</span>
                    </li>
                `;
            });
            html += '</ul>';
        } else {
            html += '<p style="color:#ccc;">Todos os times estão vinculados!</p>';
        }

        teamsContainer.innerHTML = html;
    }

    // --- Funções do Perfil do Time (Modal) ---
    
    function openPerfilTime(teamName) {
        const teamInfo = teamData[teamName];
        if (!teamInfo) {
            alert('Time não encontrado.');
            return;
        }

        document.getElementById('perfil-time-nome').textContent = teamName;
        document.getElementById('perfil-time-logo').src = teamInfo.logo;
        document.getElementById('perfil-time-serie').textContent = teamInfo.series;

        // 1. Informação do Usuário
        const teamOwner = allUsersCache.find(u => u.teamName === teamName);
        const ownerName = teamOwner ? (teamOwner.userName || teamOwner.email) : 'Gerente Não Atribuído';
        document.getElementById('perfil-time-user-name').textContent = `Gerente: ${ownerName}`;
        
        // 2. Estatísticas
        const teamStats = allUsersCache.find(u => u.teamName === teamName && u.stats)?.stats || defaultStats;
        const statsHtml = `
            <p><strong>Pontos:</strong> ${teamStats.Pontos}</p>
            <p><strong>Jogos:</strong> ${teamStats.Jogos}</p>
            <p><strong>Vitórias/Empates/Derrotas:</strong> ${teamStats.Vitórias} / ${teamStats.Empates} / ${teamStats.Derrotas}</p>
            <p><strong>Gols Pró/Contra (Saldo):</strong> ${teamStats.GolsPro} / ${teamStats.GolsContra} (${teamStats.Saldo})</p>
        `;
        document.getElementById('perfil-time-stats').innerHTML = statsHtml;

        // 3. Posts Recentes
        const teamPosts = allPostsCache.filter(p => p.authorId === teamOwner?.uid);
        const feedContainer = document.getElementById('perfil-time-feed');
        feedContainer.innerHTML = '';
        if (teamPosts.length > 0) {
             teamPosts.slice(0, 3).forEach(post => { // Mostra os 3 mais recentes
                let dateStr = post.timestamp && post.timestamp.toDate ? post.timestamp.toDate().toLocaleString('pt-BR', { day: 'numeric', month: 'short' }) : 'data indisponível';
                feedContainer.innerHTML += `
                    <div style="background: rgba(0,255,150,0.1); padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                        <p style="font-size: 0.9em; color: #ccc;">${post.content}</p>
                        <span style="font-size: 0.75em; color: #999;">Publicado em ${dateStr}</span>
                    </div>
                `;
            });
        } else {
            feedContainer.innerHTML = '<p style="color:#ccc;">Este time ainda não publicou nada.</p>';
        }

        document.getElementById('perfil-time').style.display = 'block';
        document.body.style.overflow = 'hidden';
    }


    // --- Funções de Admin (Painel) ---
    
    // Função para preencher os <select> de Time 1 e Time 2 no painel admin
    function filterTeamsBySeries(series) {
        const team1Select = document.getElementById('jogo-time1');
        const team2Select = document.getElementById('jogo-time2');
        
        // Limpa as opções anteriores
        team1Select.innerHTML = '<option value="">-- Selecione o Time --</option>';
        team2Select.innerHTML = '<option value="">-- Selecione o Time --</option>';

        if (!series) return;

        const filteredTeams = Object.keys(teamData).filter(teamName => teamData[teamName].series === series);

        filteredTeams.forEach(teamName => {
            const option = `<option value="${teamName}">${teamName}</option>`;
            team1Select.innerHTML += option;
            team2Select.innerHTML += option;
        });
    }

    // Renderiza a lista de times para vinculação no painel ADM
    function renderAdminTeamList() {
        const listContainer = document.getElementById('admin-teams-list');
        if (!listContainer) return; // Garante que só executa se o painel estiver na página

        listContainer.innerHTML = '';
        
        const unlinkedTeams = Object.keys(teamData).filter(teamName => 
            !allUsersCache.some(u => u.teamName === teamName)
        );

        let html = '<h4 style="color:#00ff96; border-bottom: 1px dashed #00ff96; padding-bottom: 5px;">Usuários Vinculados</h4>';
        
        // 1. Tabela de Usuários com Times Vinculados
        const linkedUsers = allUsersCache.filter(u => u.teamName);
        if (linkedUsers.length > 0) {
            html += '<table style="font-size:0.9em;"><thead><tr><th>Usuário</th><th>Time</th><th>Ações</th></tr></thead><tbody>';
            linkedUsers.forEach(user => {
                html += `
                    <tr>
                        <td style="text-align: left;">${user.userName}</td>
                        <td>${user.teamName}</td>
                        <td>
                            <button onclick="unlinkTeam('${user.uid}')" style="background:#ff004c; color:white; border:none; padding: 5px 10px; border-radius: 5px; cursor:pointer;">Desvincular</button>
                        </td>
                    </tr>
                `;
            });
            html += '</tbody></table>';
        } else {
            html += '<p style="color:#ccc;">Nenhum usuário com time atribuído.</p>';
        }
        
        // 2. Tabela de Times Disponíveis para Atribuição
        html += '<h4 style="color:#f2c94c; border-bottom: 1px dashed #f2c94c; padding-bottom: 5px; margin-top: 20px;">Atribuir Times Disponíveis</h4>';

        if (unlinkedTeams.length > 0) {
            html += '<table style="font-size:0.9em;"><thead><tr><th>Time</th><th>Série</th><th>Usuário</th><th>Ação</th></tr></thead><tbody>';
            unlinkedTeams.forEach(teamName => {
                const userOptions = allUsersCache
                    .filter(u => !u.teamName) // Apenas usuários SEM time
                    .map(u => `<option value="${u.uid}">${u.userName || u.email}</option>`)
                    .join('');

                html += `
                    <tr>
                        <td style="text-align: left;">${teamName}</td>
                        <td>${teamData[teamName].series}</td>
                        <td>
                            <select id="user-select-${teamName}" class="login-input" style="width:100%; padding: 5px; margin: 0;">
                                <option value="">-- Selecione o Usuário --</option>
                                ${userOptions}
                            </select>
                        </td>
                        <td>
                            <button onclick="linkTeamToUser('${teamName}')" style="background:#00ff96; color:#0a1324; border:none; padding: 5px 10px; border-radius: 5px; cursor:pointer;">Vincular</button>
                        </td>
                    </tr>
                `;
            });
            html += '</tbody></table>';
        } else {
            html += '<p style="color:#ccc;">Todos os times estão vinculados!</p>';
        }

        listContainer.innerHTML += html;
    }

    // Lógica para vincular um time a um usuário (no Painel ADM)
    async function linkTeamToUser(teamName) {
        const userSelect = document.getElementById(`user-select-${teamName}`);
        const userId = userSelect.value;
        const userName = userSelect.options[userSelect.selectedIndex].text;
        
        if (!userId) {
            alert('Selecione um usuário para vincular.');
            return;
        }

        if (!confirm(`Tem certeza que deseja vincular o time ${teamName} ao usuário ${userName}?`)) return;

        try {
            // Inicializa as estatísticas zeradas
            const initialStats = {
                Pontos: 0, Jogos: 0, Vitórias: 0, Empates: 0, Derrotas: 0, GolsPro: 0, GolsContra: 0, Saldo: 0
            };
            
            // 1. Atualiza o documento do usuário
            await usersCollection.doc(userId).update({
                teamId: teamName, // Usamos o nome do time como o ID do time
                teamName: teamName,
                stats: initialStats
            });
            
            alert(`✅ ${teamName} vinculado a ${userName} com sucesso!`);
            // Os Listeners do Firestore atualizarão o cache e a UI
        } catch (error) {
            console.error("Erro ao vincular time:", error);
            alert("❌ Erro ao vincular time. Verifique suas regras de segurança.");
        }
    }

    // Lógica para desvincular um time de um usuário (no Painel ADM)
    async function unlinkTeam(userId) {
        const user = allUsersCache.find(u => u.uid === userId);
        if (!user || !user.teamName) return;

        if (!confirm(`Tem certeza que deseja desvincular o time ${user.teamName} do usuário ${user.userName}?`)) return;

        try {
            // 1. Remove as chaves de time e estatísticas do documento do usuário
            await usersCollection.doc(userId).update({
                teamId: firebase.firestore.FieldValue.delete(),
                teamName: firebase.firestore.FieldValue.delete(),
                stats: firebase.firestore.FieldValue.delete()
            });
            
            alert(`✅ Time ${user.teamName} desvinculado com sucesso!`);
            // Os Listeners do Firestore atualizarão o cache e a UI
        } catch (error) {
            console.error("Erro ao desvincular time:", error);
            alert("❌ Erro ao desvincular time. Verifique suas regras de segurança.");
        }
    }


    // Lógica para registrar um resultado de jogo (no Painel ADM)
    async function registrarResultado() {
        const series = document.getElementById('jogo-series').value;
        const time1 = document.getElementById('jogo-time1').value;
        const time2 = document.getElementById('jogo-time2').value;
        const gols1 = parseInt(document.getElementById('jogo-gols1').value);
        const gols2 = parseInt(document.getElementById('jogo-gols2').value);

        if (!series || !time1 || !time2 || isNaN(gols1) || isNaN(gols2) || time1 === time2) {
            alert('Preencha todos os campos corretamente e garanta que os times são diferentes.');
            return;
        }

        if (!confirm(`Confirmar resultado: ${time1} ${gols1} x ${gols2} ${time2} (${series})?`)) return;

        try {
            // Funções para atualizar as estatísticas de um time no Firestore
            const updateTeamStats = async (teamName, teamGols, oppGols) => {
                const user = allUsersCache.find(u => u.teamName === teamName);
                if (!user) {
                    console.warn(`Time ${teamName} não está vinculado a um usuário. Estatísticas ignoradas.`);
                    return; // Ignora se o time não tem usuário vinculado
                }
                
                let pontos = 0;
                let v = 0;
                let e = 0;
                let d = 0;

                if (teamGols > oppGols) {
                    pontos = 3; v = 1;
                } else if (teamGols === oppGols) {
                    pontos = 1; e = 1;
                } else {
                    d = 1;
                }

                // Obtém a referência ao documento do usuário (que contém as estatísticas do time)
                const userRef = usersCollection.doc(user.uid);
                
                // Atualiza o objeto 'stats' usando transação para garantir atomicidade
                await db.runTransaction(async (transaction) => {
                    const doc = await transaction.get(userRef);
                    if (!doc.exists) return; // Se o documento for deletado, aborta
                    
                    const currentStats = doc.data().stats || defaultStats;

                    // Atualiza as estatísticas no objeto
                    const newStats = {
                        Pontos: currentStats.Pontos + pontos,
                        Jogos: currentStats.Jogos + 1,
                        Vitórias: currentStats.Vitórias + v,
                        Empates: currentStats.Empates + e,
                        Derrotas: currentStats.Derrotas + d,
                        GolsPro: currentStats.GolsPro + teamGols,
                        GolsContra: currentStats.GolsContra + oppGols,
                        // O Saldo será recalculado no front-end para simplificar o update no Firestore
                        Saldo: 0 // Será redefinido na função calculateStats
                    };

                    transaction.update(userRef, { stats: newStats });
                });
            };

            // Atualiza o Time 1
            await updateTeamStats(time1, gols1, gols2);
            
            // Atualiza o Time 2
            await updateTeamStats(time2, gols2, gols1);
            
            // Log do Resultado (Opcional)
            await logsCollection.add({
                game: `${time1} ${gols1} x ${gols2} ${time2}`,
                series: series,
                adminId: loggedInUserUID,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });

            alert(`✅ Resultado registrado: ${time1} ${gols1} x ${gols2} ${time2}. As tabelas foram atualizadas.`);
            
            // Limpa os campos do formulário
            document.getElementById('jogo-series').value = '';
            document.getElementById('jogo-time1').innerHTML = '<option value="">-- Selecione o Time --</option>';
            document.getElementById('jogo-time2').innerHTML = '<option value="">-- Selecione o Time --</option>';
            document.getElementById('jogo-gols1').value = '';
            document.getElementById('jogo-gols2').value = '';

        } catch (error) {
            console.error("Erro ao registrar resultado:", error);
            alert("❌ Falha ao registrar resultado. Verifique o console para detalhes.");
        }
    }
</script>
</body>
</html>
